# Grammar for Fuga

single_input[ast_list_t *]:
    | NEWLINE { ast_list_of(p, ast_nop(p)) }
    | simple_statements { ast_list_of(p, %a) }
    | compound_statement NEWLINE { ast_list_of(p, %a) }
file_input[ast_list_t *]:
    | statement_list { a }
eval_input[ast_list_t *]:
    | exprlist [NEWLINE] { a }

# Statements
statement_list[ast_list_t *]:
    | line_statement+ { a }
line_statement[ast_list_t *]:
    | simple_statements NEWLINE { a }
    | compound_statement NEWLINE { ast_list_of(p, %a) }

simple_statements[ast_list_t *]:
    | ';'.simple_statement+ [';'] { a }


# Small Statements
simple_statement[ast_stmt_t *]:
    | assignment { a }
    | exprlist_star { node(p) }
    | 'pass' { ast_nop(p) }
    | 'break' { ast_break(p) }
    | 'continue' { ast_continue(p) }
    | 'return' [exprlist_star] >> { ast_return(p, %a) }
    | 'raise' expr ['from' expr >> [ast_expr_t *]
        { a }] >> { ast_nop(p) }
    | 'del' targetlist >> { ast_del(p, %a) }


# Expression groups
star_expr[ast_expr_t *] (inline):
    | '*' bitwise_or { a }
exprlist[ast_list_t *]:
    | ','.expr+ [','] { a }

target (memo):
    | t_primary '.' NAME !t_lookahead >> { node(p) }
    | t_primary subscript !t_lookahead >> { node(p) }
    | NAME
t_primary[ast_primary_t *] (left_recursive):
    | t_primary '.' NAME &t_lookahead >> { node(p) }
    | t_primary invocation &t_lookahead >> { node(p) }
    | t_primary subscript &t_lookahead >> { node(p) }
    | atom &t_lookahead { a }
t_lookahead[void *] (inline):
    | '.'
    | '('
    | '['

targetlist[ast_list_t *]:
    | ','.target+ [','] { a }
expr_or_star:
    | star_expr
    | expr
exprlist_star[ast_list_t *]:
    | ','.expr_or_star+ [','] { a }

subscript[ast_list_t *]:
    | '[' ','.slice+ [','] ']' { a }
slice:
    | [expr] slice_expr [slice_expr]
    | expr
slice_expr:
    | ':' [expr] { a }

list_item:
    | star_expr
    | named_expression
list_items[ast_list_t *]:
    | ','.list_item+ [','] { a }


# Assignments

assignment:
    | target ':' expr ['=' exprlist >> { a }] >> { node(p) }
    | (targetlist '=' >> { a })+ exprlist_star >> { node(p) }
    | target augmented_assign exprlist >> { node(p) }
augmented_assign[int *]:
    | '+='  { ast_integer(p, BINOP_PLS) }
    | '-='  { ast_integer(p, BINOP_MIN) }
    | '*='  { ast_integer(p, BINOP_MUL) }
    | '/='  { ast_integer(p, BINOP_DIV) }
    | '%='  { ast_integer(p, BINOP_MOD) }
    | '@='  { ast_integer(p, BINOP_MML) }
    | '|='  { ast_integer(p, BINOP_IOR) }
    | '&='  { ast_integer(p, BINOP_AND) }
    | '^='  { ast_integer(p, BINOP_XOR) }
    | '//=' { ast_integer(p, BINOP_FDV) }
    | '**=' { ast_integer(p, BINOP_POW) }
    | '<<=' { ast_integer(p, BINOP_SHL) }
    | '>>=' { ast_integer(p, BINOP_SHR) }


# Compound statements

compound_statement:
    | if_statement
    | while_statement
    | for_statement
    | try_statement
    | with_statement

if_statement:
    | 'if' named_expression suite elif_statement* [else_suite]
elif_statement:
    | 'elif' named_expression suite
while_statement:
    | 'while' named_expression suite [else_suite]
for_statement:
    | 'for' targetlist 'in' exprlist suite [else_suite]
try_statement:
    | 'try' suite (except_suite | finally_suite)
with_statement:
    | 'with' ','.expr_as_name+ suite
expr_as_name:
    | expr ['as' NAME >> [token_t]{ a }]

# Suites

block_suite:
    | '{' NEWLINE statement_list '}' { b }
    | '{' [simple_statements] '}' { a }
suite:
    | ':' simple_statements { a }
    | block_suite { a }
else_suite:
    | 'else' suite { a }
finally_suite:
    | 'finally' suite { a }
except_clause:
    | 'except' [expr_as_name] suite
except_suite:
    | except_clause+ [else_suite] [finally_suite]

# Function calls

invocation:
    | '(' [','.call_arg+  [','] { a } ] ')' { a }
call_arg:
    | NAME ':=' expr
    | NAME '=' expr
    | '**' expr
    | '*' expr
    | expr

# Builder definitions

typed_arg_list:
    | kwargs
    | args_kwargs
    | full_arg_list
full_arg_list:
    | ','.default_arg+ [','  [kwargs | args_kwargs]]
args_kwargs:
    | '*' [typed_arg] (','  default_arg { a })* [','  [kwargs]]
kwargs:
    | '**' typed_arg [','] { a }
default_arg:
    | typed_arg ['=' expr { a }]
typed_arg:
    | NAME [':' expr { a }]
simple_arg:
    | NAME ['=' expr { a }]
simple_args[ast_list_t]:
    | ','.simple_arg+ { a }
builder_hint[ast_list_t]:
    | '<' ','.NAME+ '>' { a }
builder_args:
    | '(' [typed_arg_list] ')'

# Expressions

named_expression[ast_named_t *]:
    | NAME ':=' expr >> { ast_named(p, %a, %b) }
    | expr { ast_unnamed(p, %a) }
conditional[ast_expr_t *] (inline):
    | 'if' disjunction '?' disjunction ':' expr
        { ast_conditional(p, %a, %b, %c) }
expr[ast_expr_t *]:
    | conditional { a }
    | disjunction { a }

disjunction[ast_expr_t *] (left_recursive):
    | disjunction 'or' conjunction >>
        { ast_binary(p, %a, %b, LOGIC_OR) }
    | conjunction { a }
conjunction[ast_expr_t *] (left_recursive):
    | conjunction 'and' inversion >>
        { ast_binary(p, %a, %b, LOGIC_AND) }
    | inversion { a }
inversion[ast_expr_t *]:
    | 'not' inversion >>
        { ast_unary(p, %a, LOGIC_NOT) }
    | comparison { a }

comparison[ast_expr_t *]:
    | bitwise_or (comparator bitwise_or >> [ast_expr_t]
            { ast_comp_term(p, %a, %b) })+ >>
        { ast_comparison(p, %a, %b) }
    | bitwise_or { a }
comparator[int *]:
    | '<' { ast_integer(p, CMP_LT) }
    | '>' { ast_integer(p, CMP_GT) }
    | '==' { ast_integer(p, CMP_EQ) }
    | '>=' { ast_integer(p, CMP_GE) }
    | '<=' { ast_integer(p, CMP_LE) }
    | '!=' { ast_integer(p, CMP_NE) }
    | 'in' { ast_integer(p, CMP_IN) }
    | 'not' 'in' >> { ast_integer(p, CMP_NI) }
    | 'is' { ast_integer(p, CMP_IS) }
    | 'is' 'not' >> { ast_integer(p, CMP_NS) }

bitwise_or[ast_expr_t *] (left_recursive):
    | bitwise_or '|' bitwise_xor >>
        { ast_binary(p, %a, %b, BINOP_IOR) }
    | bitwise_xor { a }
bitwise_xor[ast_expr_t *] (left_recursive):
    | bitwise_xor '^' bitwise_and >>
        { ast_binary(p, %a, %b, BINOP_XOR) }
    | bitwise_and { a }
bitwise_and[ast_expr_t *] (left_recursive):
    | bitwise_and '&' bitwise_shift >>
        { ast_binary(p, %a, %b, BINOP_AND) }
    | bitwise_shift { a }
bitwise_shift[ast_expr_t *] (left_recursive):
    | bitwise_shift '<<' sum >>
        { ast_binary(p, %a, %b, BINOP_SHL) }
    | bitwise_shift '>>' sum >>
        { ast_binary(p, %a, %b, BINOP_SHR) }
    | sum { a }

sum[ast_expr_t *] (left_recursive):
    | sum '+' term >>
        { ast_binary(p, %a, %b, BINOP_PLS) }
    | sum '-' term >>
        { ast_binary(p, %a, %b, BINOP_MIN) }
    | term { a }
term[ast_expr_t *] (left_recursive):
    | term '*' pipeline >>
        { ast_binary(p, %a, %b, BINOP_MUL) }
    | term '/' pipeline >>
        { ast_binary(p, %a, %b, BINOP_DIV) }
    | term '%' pipeline >>
        { ast_binary(p, %a, %b, BINOP_MOD) }
    | term '//' pipeline >>
        { ast_binary(p, %a, %b, BINOP_FDV) }
    | term '@' pipeline >>
        { ast_binary(p, %a, %b, BINOP_MML) }
    | pipeline { a }

pipeline[ast_expr_t *] (left_recursive):
    | pipeline '->' factor >>
        { ast_binary(p, %a, %b, BINOP_PIP) }
    | factor { a }

factor[ast_expr_t *] (memo):
    | '+' factor >> { ast_unary(p, %a, UNARY_PLS) }
    | '-' factor >> { ast_unary(p, %a, UNARY_MIN) }
    | '~' factor >> { ast_unary(p, %a, UNARY_INV) }
    | power { a }

power[ast_expr_t *] (memo):
    | primary '**' factor >>
        { ast_binary(p, ast_primary_expr(p, %a), %b, BINOP_POW) }
    | primary { ast_primary_expr(p, %a) }

primary[ast_primary_t *] (left_recursive):
    | primary '.' NAME >> { node(p) }
    | primary invocation >> { node(p) }
    | primary subscript >> { node(p) }
    | atom

paren_expression[ast_primary_t *] (inline):
    | '(' [list_items] ')'
list_expression[ast_primary_t *] (inline):
    | '[' [list_items] ']'

builder_expression[ast_primary_t *] (inline):
    | NAME simple_args ':' expr
    | NAME [builder_hint] [builder_args] block_suite

atom[ast_primary_t *] (memo):
    | paren_expression
    | list_expression
    | builder_expression
    | NAME { ast_name_atom(p, %a) }
    | NUMBER { ast_number_atom(p, %a) }
    | STRING { ast_string_atom(p, %a) }
    | 'None' { ast_none(p) }
    | 'True' { ast_true(p) }
    | 'False' { ast_false(p) }
