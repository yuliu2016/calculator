# Grammar for Fuga

single_input[ast_list_t]:
    | NEWLINE { "ast_list_of(p, ast_nop(p))" }
    | simple_stmt { "ast_list_of(p, %a)" }
    | compound_stmt NEWLINE { "ast_list_of(p, %a)" }
file_input[ast_list_t]:
    | stmt_list { a }
eval_input[ast_list_t]:
    | exprlist [NEWLINE] { a }

# Statements
stmt_list[ast_list_t]:
    | stmt+ { a }
stmt[ast_stmt_t]:
    | (simple_stmt | compound_stmt) NEWLINE { a }
simple_stmt[ast_list_t]:
    | ';'.small_stmt+ [';'] { a }

# Small Statements
small_stmt[ast_stmt_t]:
    | 'pass' { "ast_nop(p)" }
    | 'break' { "ast_break(p)" }
    | 'continue' { "ast_continue(p)" }
    | return_stmt
    | raise_stmt
    | del_stmt
    | nonlocal_stmt
    | assert_stmt
    | assignment

del_stmt[ast_stmt_t]:
    | 'del' targetlist
return_stmt[ast_stmt_t]:
    | 'return' [exprlist_star]
raise_stmt[ast_stmt_t]:
    | 'raise' expr ['from' expr]
nonlocal_stmt[ast_stmt_t]:
    | 'nonlocal' name_list
assert_stmt[ast_stmt_t]:
    | 'assert' expr [',' expr]

# Expression groups
name_list[ast_list_t]:
    | ','.NAME+ { a }
star_expr[ast_expr_t]:
    | '*' bitwise_or { a }
exprlist[ast_list_t]:
    | ','.expr+ [','] { a }
target:
    | t_primary '.' NAME !t_lookahead
    | t_primary subscript !t_lookahead
    | NAME
    | '(' targetlist ')'
t_primary[ast_primary_t] (left_recursive):
    | t_primary '.' NAME &t_lookahead
    | t_primary invocation &t_lookahead
    | t_primary subscript &t_lookahead
    | atom &t_lookahead
t_lookahead[void]:
    | '.'
    | '('
    | '['
targetlist[ast_list_t]:
    | ','.target+ [','] { a }
expr_or_star:
    | star_expr
    | expr
exprlist_star[ast_list_t]:
    | ','.expr_or_star+ [','] { a }

subscript[ast_list_t]:
    | '[' slicelist ']'
slicelist[ast_list_t]:
    | ','.slice+ [','] { a }
slice:
    | [expr] slice_expr [slice_expr]
    | expr
slice_expr:
    | ':' [expr]

list_item:
    | star_expr
    | named_expr
list_items[ast_list_t]:
    | ','.list_item+ [','] { a }
as_name:
    | 'as' NAME


# Assignments

assignment:
    | annassign
    | augassign
    | simple_assign
annassign:
    | target ':' expr ['=' exprlist]
augassign:
    | target augassign_op exprlist
simple_assign:
    | (targetlist '=')* exprlist_star
augassign_op[int]:
    | '+='  { "ast_integer(p, BINOP_PLS)" }
    | '-='  { "ast_integer(p, BINOP_MIN)" }
    | '*='  { "ast_integer(p, BINOP_MUL)" }
    | '/='  { "ast_integer(p, BINOP_DIV)" }
    | '%='  { "ast_integer(p, BINOP_MOD)" }
    | '@='  { "ast_integer(p, BINOP_MML)" }
    | '|='  { "ast_integer(p, BINOP_IOR)" }
    | '&='  { "ast_integer(p, BINOP_AND)" }
    | '^='  { "ast_integer(p, BINOP_XOR)" }
    | '//=' { "ast_integer(p, BINOP_FDV)" }
    | '**=' { "ast_integer(p, BINOP_POW)" }
    | '<<=' { "ast_integer(p, BINOP_SHL)" }
    | '>>=' { "ast_integer(p, BINOP_SHR)" }


# Compound statements

compound_stmt:
    | if_stmt
    | while_stmt
    | for_stmt
    | try_stmt
    | with_stmt

if_stmt:
    | 'if' named_expr suite elif_stmt* [else_suite]
elif_stmt:
    | 'elif' named_expr suite
while_stmt:
    | 'while' named_expr suite [else_suite]
for_stmt:
    | 'for' targetlist 'in' exprlist suite [else_suite]
try_stmt:
    | 'try' suite (except_suite | finally_suite)
with_stmt:
    | 'with' ','.expr_as_name+ suite
expr_as_name:
    | expr [as_name]

# Suites

block_suite:
    | '{' NEWLINE stmt_list '}'
    | '{' [simple_stmt] '}'
suite:
    | ':' simple_stmt
    | block_suite
else_suite:
    | 'else' suite
finally_suite:
    | 'finally' suite
except_clause:
    | 'except' [expr_as_name] suite
except_suite:
    | except_clause+ [else_suite] [finally_suite]

# Function calls

invocation:
    | '(' [call_arg_list] ')'
call_arg_list[ast_list_t]:
    | ','.call_arg+  [','] { a }
call_arg:
    | NAME ':=' expr
    | NAME '=' expr
    | '**' expr
    | '*' expr
    | expr

# Builder definitions

typed_arg_list:
    | kwargs
    | args_kwargs
    | full_arg_list
full_arg_list:
    | ','.default_arg+ [','  [kwargs | args_kwargs]]
args_kwargs:
    | '*' [typed_arg] (','  default_arg)* [','  [kwargs]]
kwargs:
    | '**' typed_arg [','] { a }
default_arg:
    | typed_arg ['=' expr]
typed_arg:
    | NAME [':' expr]
simple_arg:
    | NAME ['=' expr]
simple_args[ast_list_t]:
    | ','.simple_arg+ { a }
builder_hint[ast_list_t]:
    | '<' name_list '>' { a }
builder_args:
    | simple_args
    | '(' [typed_arg_list] ')'

# Expressions

named_expr[ast_named_t]:
    | NAME ':=' expr { "ast_named(p, %a, %b)" }
    | expr { "ast_unnamed(p, %a)" }
conditional[ast_expr_t]:
    | 'if' disjunction '?' disjunction ':' expr { "ast_conditional(p, %a, %b, %c)"}
expr[ast_expr_t]:
    | conditional { a }
    | disjunction { a }
disjunction[ast_expr_t] (left_recursive):
    | disjunction 'or' conjunction { "ast_binary(p, %a, %b, LOGIC_OR)" }
    | conjunction { a }
conjunction[ast_expr_t] (left_recursive):
    | conjunction 'and' inversion { "ast_binary(p, %a, %b, LOGIC_AND)" }
    | inversion { a }
inversion[ast_expr_t]:
    | 'not' inversion { "ast_unary(p, %a, LOGIC_NOT)"}
    | comparison { a }
comparison[ast_expr_t]:
    | bitwise_or (comp_op bitwise_or { "ast_comp_term(p, %a, %b)" })+ { "ast_comparison(p, %a, %b)" }
    | bitwise_or { a }
comp_op[int]:
    | '<' { "ast_integer(p, CMP_LT)" }
    | '>' { "ast_integer(p, CMP_GT)" }
    | '==' { "ast_integer(p, CMP_EQ)" }
    | '>=' { "ast_integer(p, CMP_GE)" }
    | '<=' { "ast_integer(p, CMP_LE)" }
    | '!=' { "ast_integer(p, CMP_NE)" }
    | 'in' { "ast_integer(p, CMP_IN)" }
    | 'not' 'in' { "ast_integer(p, CMP_NI)" }
    | 'is' { "ast_integer(p, CMP_IS)" }
    | 'is' 'not' { "ast_integer(p, CMP_NS)" }
bitwise_or[ast_expr_t] (left_recursive):
    | bitwise_or '|' bitwise_xor { "ast_binary(p, %a, %b, BINOP_IOR)" }
    | bitwise_xor { a }
bitwise_xor[ast_expr_t] (left_recursive):
    | bitwise_xor '^' bitwise_and { "ast_binary(p, %a, %b, BINOP_XOR)" }
    | bitwise_and { a }
bitwise_and[ast_expr_t] (left_recursive):
    | bitwise_and '&' shift_expr { "ast_binary(p, %a, %b, BINOP_AND)" }
    | shift_expr { a }
shift_expr[ast_expr_t] (left_recursive):
    | shift_expr '<<' sum { "ast_binary(p, %a, %b, BINOP_SHL)" }
    | shift_expr '>>' sum { "ast_binary(p, %a, %b, BINOP_SHR)" }
    | sum { a }
sum[ast_expr_t] (left_recursive):
    | sum '+' term { "ast_binary(p, %a, %b, BINOP_PLS)" }
    | sum '-' term { "ast_binary(p, %a, %b, BINOP_MIN)" }
    | term { a }
term[ast_expr_t] (left_recursive):
    | term '*' pipe_expr { "ast_binary(p, %a, %b, BINOP_MUL)" }
    | term '/' pipe_expr { "ast_binary(p, %a, %b, BINOP_DIV)" }
    | term '%' pipe_expr { "ast_binary(p, %a, %b, BINOP_MOD)" }
    | term '//' pipe_expr { "ast_binary(p, %a, %b, BINOP_FDV)" }
    | term '@' pipe_expr { "ast_binary(p, %a, %b, BINOP_MML)" }
    | pipe_expr { a }
pipe_expr[ast_expr_t] (left_recursive):
    | pipe_expr '->' factor { "ast_binary(p, %a, %b, BINOP_PIP)" }
    | factor { a }
factor[ast_expr_t]:
    | '+' factor { "ast_unary(p, %a, UNARY_PLS)" }
    | '-' factor { "ast_unary(p, %a, UNARY_MIN)" }
    | '~' factor { "ast_unary(p, %a, UNARY_INV)" }
    | power { a }
power[ast_expr_t]:
    | primary '**' factor { "ast_binary(p, ast_primary_expr(p, %a), %b, BINOP_POW)" }
    | primary { "ast_primary_expr(p, %a)" }
primary[ast_primary_t] (left_recursive):
    | primary '.' NAME
    | primary invocation
    | primary subscript
    | atom
tuple_atom[ast_atom_t]:
    | '(' [list_items] ')'
list_atom[ast_atom_t]:
    | '[' [list_items] ']'
builder[ast_atom_t]:
    | NAME simple_args ':' expr
    | NAME [builder_hint] [builder_args] block_suite
atom[ast_atom_t]:
    | tuple_atom
    | list_atom
    | builder
    | NAME
    | NUMBER
    | STRING
    | 'None'
    | 'True'
    | 'False'
