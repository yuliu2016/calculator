# Grammar for Fuga

single_input: NEWLINE | simple_stmt | compound_stmt NEWLINE
file_input: (NEWLINE | stmt)* ENDMARKER
eval_input: exprlist NEWLINE* ENDMARKER

# Statements
stmt: (simple_stmt | compound_stmt) NEWLINE
simple_stmt: small_stmt (';' small_stmt)* [';']

# Small Statements
small_stmt: expr_stmt | del_stmt | pass_stmt | flow_stmt | import_stmt | assert_stmt

expr_or_star: expr | star_expr
exprlist_star: expr_or_star (',' expr_or_star)* [',']
augassign: '+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=' | '**=' | '//='
expr_stmt: exprlist_star [augassign exprlist | ('=' exprlist_star)*]

del_stmt: 'del' targets
pass_stmt: 'pass'

flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt
break_stmt: 'break'
continue_stmt: 'continue'
return_stmt: 'return' [exprlist_star]
raise_stmt: 'raise' [expr ['from' expr]]

import_stmt: import_name | import_from
import_name: 'import' dotted_as_names
import_from: 'from' ('.'* dotted_name | '.'+) 'import' ('*' | '(' import_as_names ')' | import_as_names)
import_as_name: NAME ['as' NAME]
dotted_as_name: dotted_name ['as' NAME]
import_as_names: import_as_name (',' import_as_name)* [',']
dotted_as_names: dotted_as_name (',' dotted_as_name)* [',']
dotted_name: NAME ('.' NAME)*

assert_stmt: 'assert' expr [',' expr]

# Compound statements
compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | with_stmt
if_stmt: 'if' namedexpr_expr suite ('elif' namedexpr_expr suite)* ['else' suite]
while_stmt: 'while' namedexpr_expr suite ['else' suite]
for_stmt: 'for' targets 'in' exprlist suite ['else' suite]
try_stmt: 'try' suite ((except_clause suite)+ ['else' suite] ['finally' suite] | 'finally' suite)
# NB compile.c makes sure that the default except clause is last
except_clause: 'except' [expr ['as' NAME]]
with_stmt: 'with' with_item (',' with_item)* suite
with_item: expr ['as' NAME]

block_suite:  '{' simple_stmt '}' | '{' NEWLINE stmt+ '}'
suite: ':' simple_stmt | block_suite

# Function definitions

varargslist: vfpdef ['=' expr] (',' vfpdef ['=' expr])*
vfpdef: NAME

funcdef: ['async'] 'def' [varargslist] (':' expr | block_suite)

# Test and Expressions

namedexpr_expr: NAME [':=' expr]
expr: 'if' disjunction '?' disjunction 'else' expr | disjunction | funcdef
disjunction: conjunction ('or' conjunction)*
conjunction: inversion ('and' inversion)*
inversion: 'not' inversion | comparison
comparison: bitwise_or (comp_op bitwise_or)*
comp_op: '<'|'>'|'=='|'>='|'<='|'!='|'in'|'not' 'in'|'is'|'is' 'not'
star_expr: '*' bitwise_or
bitwise_or: bitwise_xor ('|' bitwise_xor)*
bitwise_xor: bitwise_and ('^' bitwise_and)*
bitwise_and: shift_expr ('&' shift_expr)*
shift_expr: sum (('<<'|'>>') sum)*
sum: term (('+'|'-') term)*
term: factor (('*'|'@'|'/'|'%'|'//') factor)*
factor: ('+'|'-'|'~') factor | power
power: pipe_expr ['**' factor]
pipe_expr: atom_expr ('->' atom_expr)*

# Atoms

atom_expr: atom # fixme ["await"] atom trailer*
atom: compound_atom | simple_atom
compound_atom: '(' [exprlist_comp] ')' | '[' [exprlist_comp_sub] ']' | '{' [dictorsetmaker] '}'
simple_atom: NAME | NUMBER | STRING | 'None' | 'True' | 'False'

exprlist_comp: expr_or_star ( comp_for | (',' expr_or_star)* [','])
exprlist_comp_sub: exprlist_comp | subscript

trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME | block_suite
subscriptlist: subscript (',' subscript)* [',']
subscript: expr | [expr] ':' [expr] [sliceop]
sliceop: ':' [expr]

targets: (bitwise_or|star_expr) (',' (bitwise_or|star_expr))* [',']
exprlist: expr (',' expr)* [',']

dictorsetmaker: dict_maker | set_maker

dict_item: expr ':' expr | '**' bitwise_or
dict_maker: dict_item (comp_for | (',' dict_item)* [','])
set_maker: expr_or_star (comp_for | (',' expr_or_star)* [','])

arglist: argument (',' argument)*  [',']
argument: NAME [comp_for] | NAME ':=' expr | NAME '=' expr | '**' expr | '*' expr

comp_iter: comp_for | comp_if
comp_for: 'for' targets 'in' disjunction # fixme [comp_iter]
comp_if: 'if' expr [comp_iter]
